캡슐화, 상속, 다형성

"""캡슐화"""-> 정의 중간고사에 나온다!!!!

▷ 클래스 접근 제어자
default : 동일 패키지의 클래스(class)에만 인스턴스(객체)를 생성가능하다.
public : 다른 패키지에서 인스턴스(객체)를 생성가능하다.

▷ 메소드 접근 제어자
private : 동일한 클래스 안에서만 접근이 가능하고, this를 사용하는 것들은 외부에서 접근 불가능하고, 상속도 안된다.
default : 접근제어자가 없는 형태로 동일한 패키지 안에서만 접근이 가능하다.
protected : 동일한 패키지 안에서 사용가능하고, 다른 패키지라도 상속받은 클래스에는 접근이 가능하다.
public : 모든 객체에서 접근 가능하다.







클래스: 객체 모양을 선언한 툴(캡슐화)
    메소드(멤버 함수)와 팔드(멤버 변수)는 모주 클래스 내에 구현ㅋ
객체:
    클래스의 모양대로 생성된 실체(instance)
    객체 내 데이터에 대한 보호, 외부 접근 제한
    *객체 외부에서는 비공개 멤버(필드, 에피소드)애 직접 접근할 수 없음, 객체 외부에서는 공개된 메소드를 통해 비공개 맴버 접근

상속 -> 일단 skip
is-a is-a-kind-of
어류는 동물의 일종이다: kind of
    부모 클래스: 수퍼 클래스
    하위 클래스: 서브클래스, 수퍼클래스를 재사용하고 새로운 특성 추가


다형성(polymorphism)
같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현
다양성 사례
    메소드 오버로딩(overloading):같은 이름이지만 다르게 작동하는 여러 매소드
    메소드 오버라이디(overriding):수퍼클래스의 메소드를 서브 클래스마다 다르게 구현

<---본론--->

클래스
    객체를 만들어내기 위한 설계도 혹은 틀
    객체의 속성(state)과 행동(behavior)포함
객체
    클래스 오먕 그대로 찍어낸 실체
        프로그램 실행우...
    클래스의 인스턴스....
필드
    객체의 데이터가 저장되는 곳
    우리가 처음 작성 할떄 왜 String Name; 이런식으로 정의하는 걸 필드라한다.

    Chair woodenChair = new Chair("나무");   //구분은 큰 의미가 없는것 같지만 그래도 정확하게 알고 넘어가자.
    객체: woodenChair이게
    인스턴스: new Chair("나무");

생성자 특징
    생성자는 메소드이다
    생성자 이름은 클래스 이름과 동일
    생성자 여러 개 작성 가능(오버로딩)
    생성자는 new를 통해 개체를 생성할 때, 객체당 한 번 호출
    생성자는 리턴 타입을 지정할 수 없음
    생성자의 목적은 객체초기화
    생성자는 객체가 생성될 때 반드시 홀출됨
        그러므로 하나 이상 선언되어야 함

 **** 모든 메소드는 필드에 있는 값들을 사용할 수 있다. 그래서 필드에 있는는 변수를 메소드 안에서 string name 이런식으로 선언을 하게 되면
 메소드 안에 지역 변수로 선언이 되는 것이다. 그래서 출동하게 됨으로 그렇게 사용하면 안된다.



 ----
 기본 생성자
 매개변수 없고 아무 작업 없이 단순 리턴하는 생성자
 디폴트 생성자라고 부름
 디폴트 생성자라고도 부름
 클래스에 생성자가 하나도 선언 되지 않은 경우, 컴파일일러에 의해자동으로 삽입.

 클래스에 생성자가 하나라도 작성한 경우
    기본 생정자 자동 삽입되지 않음

"this"
:자신의 객체에 접근 할 때 사용된다.

this 가 필요한 경우
    객체의 맴버 변수와 매소드 변수의 이름이 같은 경우
    다른 메소드 호출
    ..

   this()와는 다른 거다!


